from flask import Flask, Response
from picamera2 import Picamera2
import cv2
import numpy as np
import threading
import logging
import sys

# Silencia logs do Flask
log = logging.getLogger('werkzeug')
log.setLevel(logging.ERROR)

app = Flask(__name__)
picam2 = Picamera2()

# Configuração de captura (160x120 para máximo FPS)
config = picam2.create_video_configuration(main={"size": (160, 120)})
picam2.configure(config)

picam2.set_controls({
    "ExposureTime": 100, 
    "AnalogueGain": 2.5,
    "FrameRate": 100 
})
picam2.start()

# --- VARIÁVEIS DE CALIBRAÇÃO ---
THRESH_FIXO = 180    
ROI_Y, ROI_H = 0, 30
LINHA_X = 80         
MARGEM = 15          

contador = 0
furo_na_linha = False
ultimo_frame = None # Para compartilhar o frame com o preview

def escutar_teclado():
    global contador
    print("\n[SISTEMA] Monitor de Teclado Ativo. Digite 'r' + Enter para resetar.\n")
    while True:
        comando = sys.stdin.read(1)
        if comando.lower() == 'r':
            contador = 0
            print(f"\n[RESET] Contador zerado!")

def process_logic():
    global contador, furo_na_linha, ultimo_frame
    while True:
        frame_raw = picam2.capture_array()
        # Converte para BGR e armazena para o preview
        frame = cv2.cvtColor(frame_raw, cv2.COLOR_BGRA2BGR)
        ultimo_frame = frame.copy() 
        
        # Lógica de processamento no ROI
        roi = frame[ROI_Y:ROI_Y+ROI_H, :]
        gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
        _, binary = cv2.threshold(gray, THRESH_FIXO, 255, cv2.THRESH_BINARY)
        
        contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        furo_agora = False
        for cnt in contours:
            if cv2.contourArea(cnt) > 20:
                x, y, w, h = cv2.boundingRect(cnt)
                if abs((x + w//2) - LINHA_X) < MARGEM:
                    furo_agora = True
                    if not furo_na_linha:
                        contador += 1
                        furo_na_linha = True
                        break
        
        if not furo_agora:
            furo_na_linha = False

# --- ROTAS FLASK ---

def gen_preview():
    """Gera o vídeo com as marcações de ROI apenas quando solicitado"""
    while True:
        # Só tenta processar se o frame já existir
        if ultimo_frame is not None:
            # Faz uma cópia para não desenhar por cima do frame original de contagem
            vis = ultimo_frame.copy()
            
            # Desenha as marcações para você ver o ROI
            # Retângulo Vermelho (ROI)
            cv2.rectangle(vis, (0, ROI_Y), (160, ROI_Y + ROI_H), (0, 0, 255), 1)
            # Linha Verde (Gatilho)
            cv2.line(vis, (LINHA_X, 0), (LINHA_X, 120), (0, 255, 0), 1)
            
            ret, buffer = cv2.imencode('.jpg', vis)
            if ret:
                yield (b'--frame\r\nContent-Type: image/jpeg\r\n\r\n' + buffer.tobytes() + b'\r\n')
        else:
            # Se não tiver frame ainda, espera um milisegundo
            import time
            time.sleep(0.1)

@app.route('/video_feed')
def video_feed():
    return Response(gen_preview(), mimetype='multipart/x-mixed-replace; boundary=frame')

@app.route('/count')
def get_count():
    return str(contador)

@app.route('/')
def index():
    # Adicionei um carimbo de tempo (timestamp) na URL da imagem para forçar o navegador a carregar
    return """
    <html>
        <body style='background:#000; color:#0f0; text-align:center; font-family:monospace;'>
            <h1>MINIOLA MONITOR</h1>
            <div id='val' style='font-size:120px;'>0</div>
            <hr style='border:1px solid #222'>
            <h3>PREVIEW DE ALINHAMENTO</h3>
            <div style="margin: 20px;">
                <img src="/video_feed" style="width:320px; border:2px solid #333; image-rendering: pixelated;">
            </div>
            <p style='color:#666;'>Se a imagem não aparecer, atualize a página (F5).</p>
            <script>
                setInterval(() => {
                    fetch('/count').then(r => r.text()).then(t => { document.getElementById('val').innerText = t; });
                }, 100);
            </script>
        </body>
    </html>
    """

# Início das Threads
threading.Thread(target=process_logic, daemon=True).start()
threading.Thread(target=escutar_teclado, daemon=True).start()

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, threaded=True)